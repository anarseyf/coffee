% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\author{}
\date{\vspace{-2.5em}}

\begin{document}

import \{ readJSONAsync, saveJSONAsync, appendJSONAsync, \} from
``../../../fileUtils''; import \{ withScriptsJsonPath \} from
``../../../server/serverUtils''; import \{ hasCoordinates,
hasNoCoordinates \} from ``./scriptUtil''; import \{ downloadIncidents,
uploadIncidents \} from ``../database''; const axios =
require(``axios'').default;

const DATA\_TOKEN = process.env.DATA\_TOKEN \textbar\textbar{}
``UXe2CGdFW4iRYikQzbDFrSPq4'';

const queueSize = 100;

const targetFile = withScriptsJsonPath(``resolved.json''); const
deadLetterQueue = withScriptsJsonPath(``unresolved.json'');

const resolveGeo = async (entries = {[}{]}) =\textgreater{} \{ if
(!entries.length) \{ console.log(``\textgreater\textgreater{} resolveGeo
\textgreater{} nothing to do''); return {[}{]}; \}

if (entries.length \textgreater{} queueSize) \{ throw
\texttt{resolve\ \textgreater{}\ requested\ more\ than\ \$\{queueSize\}\ items:\ \$\{entries.length\}};
\}

const ids = entries.map((\{ id\_str \}) =\textgreater{} id\_str);
console.log(\texttt{resolve\ \textgreater{}\ IDs:\ \$\{ids\}}); const
list = ids.map((id) =\textgreater{} \texttt{"\$\{id\}"}).join(``,'');
const where = \texttt{incident\_number\ in(\$\{list\})};

// const appToken = ``DvY4gobAudCWKcwYz3yqTd25h'';

const uri =
\texttt{https://data.seattle.gov/resource/fire-911.json?\$\$app\_token=\$\{DATA\_TOKEN\}\&\$select=incident\_number,latitude,longitude\&\$where=\$\{where\}};
const encodedUri = encodeURI(uri);

console.log(\texttt{resolve\ \textgreater{}\ \$\{ids.length\}\ ids\ (URI\ length:\ \$\{encodedUri.length\})});

const res = await axios.get(encodedUri, \{\}).catch((e) =\textgreater{}
\{ console.error( ``data fetch call failed:'', ``\n'', encodedUri,
``\n'', e \&\& e.toString ? e.toString() : e ); \});

const geoData = res ? res.data : {[}{]};

const result = entries.map((\{ id\_str, \ldots rest \}) =\textgreater{}
\{ const \{ latitude, longitude, incident\_number \} = geoData.find((\{
incident\_number \}) =\textgreater{} id\_str === incident\_number)
\textbar\textbar{} \{\};

\begin{verbatim}
let lat, long;
if (incident_number && latitude && longitude) {
  lat = +latitude;
  long = +longitude;
}

return {
  id_str,
  lat,
  long,
  ...rest,
};
\end{verbatim}

\});

return result; \};

const resolveLocally = async (sourceFile) =\textgreater{} \{ const
entries = await readJSONAsync(sourceFile, {[}{]});

const ids = entries.map((\{ id\_str \}) =\textgreater{} id\_str); const
dbEntries = await downloadIncidents(ids);

const incidentsMap = dbEntries.reduce((map, \{ id, lat, long \})
=\textgreater{} \{ map{[}id{]} = {[}lat, long{]}; return map; \}, \{\});

const empty = {[}{]}; const result = entries.map((\{ id\_str, lat, long,
\ldots rest \}) =\textgreater{} \{ const {[}newLat, newLong{]} = lat ?
{[}lat, long{]} : incidentsMap{[}id\_str{]} \textbar\textbar{} empty;
return \{ id\_str, \ldots rest, lat: newLat, long: newLong, \}; \});
const unresolved = result.filter(hasNoCoordinates); await
saveJSONAsync(sourceFile, unresolved); const resolved =
result.filter(hasCoordinates); await appendJSONAsync(targetFile,
resolved); console.log(
\texttt{\textgreater{}\textgreater{}\ resolveLocally\ \textgreater{}\ resolved\ \$\{resolved.length\}\ out\ of\ \$\{result.length\}}
); \};

const cleanupUnresolved = async (incidentsMap) =\textgreater{} \{ //
TODO - revisit const unresolved = await readJSONAsync(deadLetterQueue,
{[}{]}); const stillUnresolved = unresolved.filter( (\{ id\_str \})
=\textgreater{} !incidentsMap{[}id\_str{]} ); await
saveJSONAsync(deadLetterQueue, stillUnresolved); console.log(
\texttt{\textgreater{}\textgreater{}\ cleanup\ unresolved\ \textgreater{}\ \$\{unresolved.length\}\ -\textgreater{}\ \$\{stillUnresolved.length\}}
); return stillUnresolved.length; \};

const saveResolved = async (entries = {[}{]}) =\textgreater{} \{ const
table = entries.map((\{ id\_str, lat, long \}) =\textgreater{} (\{ id:
id\_str, lat, long, \}));

await uploadIncidents(table); \};

export const runner = async (sourceFile) =\textgreater{} \{ try \{ if
(!sourceFile) \{ throw ``resolve \textgreater{} No source file
provided''; \} const start = new Date(); let resolvedTotal = 0,
unresolvedTotal = 0;

\begin{verbatim}
await resolveLocally(sourceFile);

for (;;) {
  const entries = await readJSONAsync(sourceFile, []);
  if (!entries.length) {
    break;
  }

  const queue = entries.slice(0, queueSize);
  if (!queue.length) {
    console.log("resolve > nothing to do");
    return targetFile;
  }

  console.log(
    `resolve > requesting ${queue.length} out of ${entries.length}`
  );

  const newData = await resolveGeo(queue);

  const resolved = newData.filter(hasCoordinates);

  await saveResolved(resolved);

  const unresolved = newData.filter(hasNoCoordinates);
  await appendJSONAsync(deadLetterQueue, unresolved, {
    merge: true,
  });

  resolvedTotal = await appendJSONAsync(targetFile, newData);
  await saveJSONAsync(sourceFile, entries.slice(queueSize)); // TODO - atomic
}

const end = new Date();
console.log(
  `resolve > new totals: resolved: ${resolvedTotal}, unresolved: ${unresolvedTotal} (${
    end - start
  }ms)`
);

return targetFile;
\end{verbatim}

\} catch (e) \{ console.error(``resolve
\textgreater\textgreater\textgreater{} stopped due to error:'', e); \}
\};

\end{document}
